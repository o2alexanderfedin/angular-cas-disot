# Data Flow Architecture üåä

[‚Üê System Architecture](./system-architecture.md) | [Home](../README.md) | [Next: Component Architecture ‚Üí](./component-architecture.md)

## Table of Contents

1. [Content Upload Flow](#content-upload-flow)
2. [Content Retrieval Flow](#content-retrieval-flow)
3. [DISOT Entry Creation](#disot-entry-creation)
4. [Signature Verification Flow](#signature-verification-flow)
5. [State Management](#state-management)

## Content Upload Flow

### Real Upload Implementation üì§

```mermaid
sequenceDiagram
    participant User
    participant ContentUploadComponent
    participant CasService
    participant HashService
    participant StorageProvider
    
    User->>ContentUploadComponent: Drag & drop file
    ContentUploadComponent->>ContentUploadComponent: FileReader.readAsArrayBuffer()
    ContentUploadComponent->>CasService: store({data: Uint8Array})
    
    CasService->>HashService: hash(data)
    HashService->>HashService: crypto.subtle.digest('SHA-256')
    HashService-->>CasService: "abc123..."
    
    CasService->>CasService: path = `content/${hash}`
    CasService->>StorageProvider: exists(path)
    
    alt New Content
        StorageProvider-->>CasService: false
        CasService->>StorageProvider: write(path, data)
        CasService->>StorageProvider: write(metadata_path, metadata)
        Note over CasService: üÜï Content stored!
    else Duplicate
        StorageProvider-->>CasService: true
        Note over CasService: ‚ôæÔ∏è Deduplication!
    end
    
    CasService-->>ContentUploadComponent: ContentHash
    ContentUploadComponent-->>User: ‚úÖ Upload complete
```

### Drag & Drop Upload Process üéØ

```mermaid
graph TD
    subgraph "User Actions"
        DRAG[üñºÔ∏è Drag file over zone]
        DROP[üì• Drop file]
        SELECT[üìÅ Or click to select]
    end
    
    subgraph "Component Processing"
        PREVENT[Prevent default browser behavior]
        READ[FileReader reads as ArrayBuffer]
        CONVERT[Convert to Uint8Array]
        UPLOAD[Call casService.store()]
    end
    
    subgraph "Results"
        HASH[üÜî SHA-256: abc123...]
        SIZE[üìä Size: 1.5 MB]
        DATE[üìÖ Date: 2025-07-05]
    end
    
    DRAG --> PREVENT
    DROP --> PREVENT
    SELECT --> READ
    PREVENT --> READ
    READ --> CONVERT
    CONVERT --> UPLOAD
    UPLOAD --> HASH
    UPLOAD --> SIZE
    UPLOAD --> DATE
```

## Content Retrieval Flow

### List & Preview Implementation üìã

```mermaid
sequenceDiagram
    participant User
    participant ContentListComponent 
    participant CasService
    participant StorageProvider
    
    User->>ContentListComponent: Navigate to content list
    ContentListComponent->>ContentListComponent: ngOnInit()
    ContentListComponent->>CasService: getAllContent()
    
    CasService->>StorageProvider: list()
    StorageProvider-->>CasService: ["content/abc123", "content/def456"]
    
    loop For each content path
        CasService->>StorageProvider: read(content_path)
        StorageProvider-->>CasService: Uint8Array data
        CasService->>StorageProvider: read(metadata_path)
        StorageProvider-->>CasService: metadata JSON
        CasService->>CasService: Create ContentWithHash
    end
    
    CasService-->>ContentListComponent: ContentWithHash[]
    
    User->>ContentListComponent: Click preview üëÅÔ∏è
    ContentListComponent->>ContentListComponent: detectContentType()
    ContentListComponent->>ContentListComponent: Show preview modal
    
    User->>ContentListComponent: Click download üì•
    ContentListComponent->>ContentListComponent: Create blob & download link
```

### Content Type Detection üîç

```mermaid
graph TD
    subgraph "Auto Detection"
        BYTES[Read first bytes]
        PNG[PNG: 89 50 4E 47]
        JPEG[JPEG: FF D8 FF]
        JSON[Try JSON.parse()]
        TEXT[UTF-8 decode]
    end
    
    subgraph "Manual Override"
        SELECT[üéØ User selects type]
        TEXT_OPT[Text]
        JSON_OPT[JSON]
        HEX_OPT[Hex]
        B64_OPT[Base64]
    end
    
    subgraph "Preview Display"
        IMG[üáºÔ∏è Image preview]
        CODE[üìù Code highlight]
        HEX_VIEW[üî¢ Hex dump]
        B64_VIEW[üî§ Base64 string]
    end
    
    BYTES --> PNG
    BYTES --> JPEG
    BYTES --> JSON
    BYTES --> TEXT
    
    PNG --> IMG
    JPEG --> IMG
    JSON --> CODE
    TEXT --> CODE
    
    SELECT --> TEXT_OPT
    SELECT --> JSON_OPT
    SELECT --> HEX_OPT
    SELECT --> B64_OPT
    
    TEXT_OPT --> CODE
    JSON_OPT --> CODE
    HEX_OPT --> HEX_VIEW
    B64_OPT --> B64_VIEW
```

## DISOT Entry Creation

### Blog Post Entry Flow üìù

```mermaid
sequenceDiagram
    participant User
    participant DisotEntryComponent
    participant CasService
    participant DisotService
    participant SignatureService
    
    User->>DisotEntryComponent: Click "Generate Key Pair" üîë
    DisotEntryComponent->>SignatureService: generateKeyPair()
    SignatureService-->>DisotEntryComponent: {privateKey, publicKey}
    
    User->>DisotEntryComponent: Select "Blog Post" type
    User->>DisotEntryComponent: Write blog content
    User->>DisotEntryComponent: Click "Create Entry"
    
    DisotEntryComponent->>DisotEntryComponent: Create blog JSON
    DisotEntryComponent->>CasService: store(blogData)
    CasService-->>DisotEntryComponent: blogContentHash
    
    DisotEntryComponent->>DisotService: createEntry(hash, BLOG_POST, privateKey)
    DisotService->>DisotService: timestamp = new Date()
    DisotService->>DisotService: Build entry data
    DisotService->>SignatureService: sign(data, privateKey)
    SignatureService-->>DisotService: signature
    
    DisotService->>DisotService: Store in entries Map
    DisotService-->>DisotEntryComponent: DisotEntry{id, signature, ...}
    
    DisotEntryComponent-->>User: ‚úÖ Entry created!
```

### Content Selection Modal Flow üîç

```mermaid
graph TD
    subgraph "Modal Trigger"
        BTN[üîò Select Content button]
        OPEN[showContentModal = true]
    end
    
    subgraph "Modal Display"
        LIST[üìã Show all content]
        SEARCH[üîç Search by hash]
        PREVIEW[üëÅÔ∏è Preview content]
    end
    
    subgraph "Selection Process"
        SELECT[üéØ User clicks Select]
        EMIT[Emit contentSelected event]
        CLOSE[Close modal]
    end
    
    subgraph "Parent Component"
        RECEIVE[onContentSelected(hash)]
        UPDATE[contentHash = hash]
        DISPLAY[Show selected hash]
    end
    
    BTN --> OPEN
    OPEN --> LIST
    LIST --> SEARCH
    LIST --> PREVIEW
    PREVIEW --> SELECT
    SELECT --> EMIT
    EMIT --> CLOSE
    EMIT --> RECEIVE
    RECEIVE --> UPDATE
    UPDATE --> DISPLAY
```

## Signature Verification Flow

### Entry Verification Process ‚úÖ

```mermaid
sequenceDiagram
    participant User
    participant SignatureVerifyComponent
    participant DisotService
    participant SignatureService
    participant HashService
    
    User->>SignatureVerifyComponent: Enter entry ID
    SignatureVerifyComponent->>DisotService: getEntry(id)
    DisotService->>DisotService: Look up in entries Map
    DisotService-->>SignatureVerifyComponent: DisotEntry | undefined
    
    alt Entry Found
        SignatureVerifyComponent->>SignatureVerifyComponent: Display entry details
        User->>SignatureVerifyComponent: Click "Verify Signature"
        
        SignatureVerifyComponent->>DisotService: verifyEntry(entry)
        DisotService->>DisotService: Reconstruct signed data
        DisotService->>HashService: hash(signedData)
        HashService-->>DisotService: dataHash
        
        DisotService->>SignatureService: verify(data, signature)
        SignatureService-->>DisotService: true (mock always returns true)
        
        DisotService-->>SignatureVerifyComponent: ‚úÖ Valid
        SignatureVerifyComponent-->>User: "Signature is valid!"
    else Entry Not Found
        SignatureVerifyComponent-->>User: ‚ùå "Entry not found"
    end
```

### Previous Entries Display üìú

```mermaid
graph TD
    subgraph "Load Previous Entries"
        INIT[Component ngOnInit]
        LIST[disotService.listEntries()]
        SORT[Sort by timestamp DESC]
    end
    
    subgraph "Display Each Entry"
        ID[üÜî Entry ID]
        TYPE[üèß Entry Type badge]
        TIME[üï∞Ô∏è Timestamp]
        HASH[#Ô∏è‚É£ Content hash]
    end
    
    subgraph "Preview Feature"
        PREV_BTN[üëÅÔ∏è Preview button]
        LOAD[Load content from CAS]
        SHOW[Show in modal/accordion]
    end
    
    INIT --> LIST
    LIST --> SORT
    SORT --> ID
    SORT --> TYPE
    SORT --> TIME
    SORT --> HASH
    
    ID --> PREV_BTN
    PREV_BTN --> LOAD
    LOAD --> SHOW
```

## State Management

### Component Loading States üîÑ

```mermaid
graph TD
    subgraph "Common Component Pattern"
        IDLE[isLoading = false<br/>errorMessage = '']
        LOADING[isLoading = true<br/>Disable buttons]
        SUCCESS[isLoading = false<br/>Show success UI]
        ERROR[isLoading = false<br/>errorMessage = 'Details']
    end
    
    subgraph "User Actions"
        UPLOAD[üì§ Upload file]
        CREATE[‚úçÔ∏è Create entry]
        VERIFY[‚úÖ Verify signature]
    end
    
    subgraph "UI Updates"
        SPINNER[üåÄ Show spinner]
        MESSAGE[üí¨ Show message]
        DISABLE[üö´ Disable inputs]
    end
    
    IDLE --> |User action| LOADING
    LOADING --> |Success| SUCCESS
    LOADING --> |Error| ERROR
    SUCCESS --> |Reset| IDLE
    ERROR --> |Retry| IDLE
    
    UPLOAD --> LOADING
    CREATE --> LOADING
    VERIFY --> LOADING
    
    LOADING --> SPINNER
    LOADING --> DISABLE
    ERROR --> MESSAGE
```

### Service Data Persistence üíæ

```mermaid
graph TD
    subgraph "CasService State"
        STORAGE[storageProvider: IStorageProvider]
        FACTORY[Selected via factory]
    end
    
    subgraph "DisotService State"
        ENTRIES[entries: Map<string, DisotEntry>]
        MEMORY[In-memory only ‚ö†Ô∏è]
    end
    
    subgraph "Storage Providers"
        MEM[üí≠ InMemoryStorage<br/>contentMap: Map<>]
        IDB[üóÑÔ∏è IndexedDbStorage<br/>cas-storage DB]
    end
    
    subgraph "Data Lifetime"
        SESSION[üïí Session only<br/>(InMemory)]
        PERSIST[üíæ Persistent<br/>(IndexedDB)]
    end
    
    STORAGE --> FACTORY
    FACTORY --> MEM
    FACTORY --> IDB
    
    ENTRIES --> MEMORY
    MEMORY --> SESSION
    
    MEM --> SESSION
    IDB --> PERSIST
    
    Note over ENTRIES: ‚ö†Ô∏è TODO: Persist DISOT entries
```

### Error Handling Examples üö´

```mermaid
graph TD
    subgraph "Common Errors"
        NO_CONTENT[‚ùå No content selected]
        NO_KEY[‚ùå No private key]
        NOT_FOUND[‚ùå Entry not found]
        STORAGE_ERR[‚ùå Storage failed]
        INIT_ERR[‚ùå IndexedDB init failed]
    end
    
    subgraph "Error Messages"
        MSG1["Please select content first"]
        MSG2["Please enter or generate a private key"]
        MSG3["Entry not found"]
        MSG4["Failed to store content"]
        MSG5["Failed to initialize IndexedDB"]
    end
    
    subgraph "User Recovery"
        SELECT[üéØ Select content]
        GENERATE[üîë Generate key]
        RETRY[üîÑ Try again]
        SWITCH[üîÑ Switch to memory storage]
    end
    
    NO_CONTENT --> MSG1
    NO_KEY --> MSG2
    NOT_FOUND --> MSG3
    STORAGE_ERR --> MSG4
    INIT_ERR --> MSG5
    
    MSG1 --> SELECT
    MSG2 --> GENERATE
    MSG3 --> RETRY
    MSG4 --> RETRY
    MSG5 --> SWITCH
```

---

[‚Üê System Architecture](./system-architecture.md) | [‚Üë Top](#data-flow-architecture) | [Home](../README.md) | [Next: Component Architecture ‚Üí](./component-architecture.md)